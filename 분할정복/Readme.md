Divide and Conquer(분할정복)
정의 : 문제를 나눌 수 없을 때 까지 나누어서 각각을 풀면서, 다시 합병하여
문제의 답을 얻는 알고리즘이다.

알고리즘 설계하는 요령
1) Divide : 문제가 분할이 가능한 경우, 2개 이상의 문제로 나눈다.
2) Conquer : 나누어진 문제가 여전히 분할이 가능하면, 또다시 Divide를 수행한다. 그렇지 않으면 문제를 푼다.
3) Combine: Conquer한 문제들을 통합하여 원래 문제의 답을 얻는다.

문제를 제대로 나누면 conquer하는 것이 쉽기 때문에 Divide를 제대로 하는 것이 가장 중요하다.
분할정복 알고리즘은 재귀 알고리즘이 많이 사용되는데, 이 부분에서 분할정복 알고리즘의 효율성을 깎아 내릴 수 있다.


[출처 : http://janghw.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Divide-and-Conquer-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5]

고정소수점처리방법
http://blog.naver.com/PostView.nhn?blogId=chogahui05&logNo=221246891984

재귀 함수(완전 정복)에서 중요 한 개념이 순열과 조합이였다면,
여기서 중요한 개념은 "세그먼트 트리"이다.

배열 A가 있고, 여기서 다음과 같은 두 연산을 수행해야하는 문제를 생각해봅시다.

[1] 구간 l, r (l ≤ r)이 주어졌을 때, A[l] + A[l+1] + ... + A[r-1] + A[r]을 구해서 출력하기
[2] i번째 수를 v로 바꾸기. A[i] = v
수행해야하는 연산은 최대 M번입니다.

세그먼트 트리나 다른 방법을 사용하지 않고 문제를 푼다면, 1번 연산을 수행하는데 O(N), 2번 연산을 수행하는데 O(1)이 걸리게 됩니다. 총 시간 복잡도는 O(NM) + O(M) = O(NM)이 나오게 됩니다.

2번 연산이 없다고 생각해봅시다.

수를 바꾸는 경우가 없기 때문에, 합도 변하지 않습니다. 따라서, 앞에서부터 차례대로 합을 구해놓는 방식으로 문제를 풀 수 있습니다.

S[i] = A[1] + ... + A[i] 라고 했을 때, i~j까지 합은 S[j] - S[i-1]이 됩니다.

i~j까지 합은 A[i] + ... + A[j]인데, S[j] = A[1] + ... + A[j], S[i-1]= A[1] + ... + A[i-1] 이기 때문입니다.

여기서 2번 연산을 하려면, 수가 바뀔때마다 S를 변경해줘야 합니다. 가장 앞에 있는 0번째 수가 바뀐 경우에는 모든 S 배열을 변경해야 하기 때문에, 시간복잡도는 O(N)이 걸리게 됩니다.

따라서, M과 N이 매우 큰 경우에는 시간이 너무 오래걸리게됩니다.

이래서 나오게 된것이 "세그먼트 트리"
[참조: https://www.acmicpc.net/blog/view/9]
